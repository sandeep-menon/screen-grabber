const {
  app,
  BrowserWindow,
  globalShortcut,
  ipcMain,
  dialog,
  ipcRenderer,
} = require("electron");
const path = require("path");
const fs = require("fs");

global.howToWindow = null;
global.mainWindow = null;
global.previewWindow = null;
global.htmlWindow = null;

const startHTML =
  "<!DOCTYPE html><html><head><meta charset='UTF-8' /><title>TITLE_CHANGE_ME</title><style>*{margin: 0;padding: 0;}.image {display: grid;height: 100%;}img {max-width: 100%;max-height: 100vh;margin: auto;}.text-image-container{display: grid;grid-template-rows: auto;text-align: center;grid-row-gap: 1em;}hr{margin-top: 1em;margin-bottom: 1em;}</style></head><body>";
const endHTML =
  "<div style='text-align: center;'>Generated by Screen Grabber</div><script type='text/javascript'>var url = window.location.pathname;var str = url.substring(url.lastIndexOf('/')+1);  str = str.substring(0, str.length - 5);var filename = str.replace(/%20/g, ' ');var filename = str.replace(/%23/g, '#');document.title = filename;</script></body></html>";

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require("electron-squirrel-startup")) {
  // eslint-disable-line global-require
  app.quit();
}

const createWindow = () => {
  // Create the browser window.
  const mainWindow = new BrowserWindow({
    width: 440,
    height: 100,
    frame: false,
    show: false,
    resizable: false,
    webPreferences: {
      nodeIntegration: true,
      enableRemoteModule: true,
    },
    icon: __dirname + "/assets/icons/favicon-32x32.png",
  });

  // and load the index.html of the app.
  mainWindow.loadFile(path.join(__dirname, "index.html"));
  mainWindow.setAlwaysOnTop(true);
  mainWindow.on("ready-to-show", () => {
    mainWindow.show();
  });
  // Open the DevTools.
  //mainWindow.webContents.openDevTools();

  app.whenReady().then(() => {
    ipcMain.on("start-listen", (event, args) => {
      let emptyData = {};
      let rawData = JSON.stringify(emptyData);
      fs.writeFileSync("imageData.json", rawData);
      globalShortcut.register("CommandOrControl+Shift+A", () => {
        mainWindow.webContents.send("capture-screenshot");
        mainWindow.webContents.send("screenshot-captured");
      });
    });

    ipcMain.on("stop-listen", (event, args) => {
      let rawData = fs.readFileSync("imageData.json");
      let jsonData = JSON.parse(rawData);

      let jsonDataLength = Object.keys(jsonData).length;

      let html = "";

      for (var i = 0; i < jsonDataLength; i++) {
        let timestamp = jsonData[i].timestamp;
        let data = jsonData[i].data;
        let comment = jsonData[i].comment;

        html +=
          "<div class='text-image-container'><div class='text'>" +
          timestamp +
          "</div><div class='text'>" +
          comment +
          "</div><div class='image'><img src='data:image/png;base64, " +
          data +
          "' /></div><hr></div>";
      }

      let options = {
        title: "Screen Grabber - Save File",
        buttonLabel: "Save Screen Grab",
        filters: [{ name: "Single HTML File", extensions: ["html"] }],
      };
      let savePath = dialog.showSaveDialogSync(options);
      if (savePath) {
        html = startHTML + html + endHTML;
        fs.writeFileSync(savePath, html);
        globalShortcut.unregisterAll();
        mainWindow.webContents.send("stopped-capture");
      }
    });
  });

  global.mainWindow = mainWindow;
};

ipcMain.on("displaying-preview", (event, args) => {
  mainWindow.setAlwaysOnTop(false);
});

ipcMain.on("preview", (event, args) => {
  globalShortcut.unregisterAll();
  mainWindow.webContents.send("stopped-capture");

  const previewWindow = new BrowserWindow({
    show: false,
    minHeight: 800,
    minWidth: 600,
    webPreferences: {
      nodeIntegration: true,
      enableRemoteModule: true,
    },
    icon: __dirname + "/assets/icons/favicon-32x32.png",
  });

  previewWindow.loadURL(path.join(__dirname, "preview.html"));

  // previewWindow.webContents.openDevTools();

  previewWindow.once("ready-to-show", () => {
    previewWindow.maximize();
    previewWindow.setMenu(null);
    previewWindow.show();
  });

  previewWindow.on("close", () => {
    mainWindow.setAlwaysOnTop(true);
    mainWindow.webContents.send("enable-start-capture");
  });

  global.previewWindow = previewWindow;
});

ipcMain.on("stop-listen-pdf", (event, args) => {
  /*
  -- As of today this functionality is not stable in Electron --
  const htmlWindow = new BrowserWindow({
    show: false,
    minHeight: 800,
    minWidth: 600,
    webPreferences: {
      nodeIntegration: true,
      enableRemoteModule: true,
    },
    icon: __dirname + "/assets/icons/favicon-32x32.png",
  });

  let options = {
    title: "Screen Grabber - Save File",
    buttonLabel: "Save Screen Grab",
    filters: [{ name: "PDF File", extensions: ["pdf"] }],
  };
  let savePath = dialog.showSaveDialogSync(options);

  if (savePath) {
    let rawData = fs.readFileSync("imageData.json");
    let jsonData = JSON.parse(rawData);
    let jsonDataLength = Object.keys(jsonData).length;
    const startPDF =
      "<!DOCTYPE html><html><head><meta charset='UTF-8' /><title>TITLE_CHANGE_ME</title><style>*{margin: 0;padding: 0;}.image {display: grid;height: 99%;}img {max-width: 99%;min-height: 99%;margin: auto;}.text-image-container{display: grid;grid-template-rows: auto;text-align: center;grid-row-gap: 1em;}hr{margin-top: 1em;margin-bottom: 1em;}@media print {.text-image-container {height: 100vh;page-break-after: always;}hr {display: none;}}</style></head><body>";
    const endPDF =
      "<div style='text-align: center;' class='text-image-container'>Generated by Screen Grabber</div><script type='text/javascript'>var url = window.location.pathname;var str = url.substring(url.lastIndexOf('/')+1);  str = str.substring(0, str.length - 5);var filename = str.replace(/%20/g, ' ');var filename = str.replace(/%23/g, '#');document.title = filename;</script></body></html>";

    let html = "";

    for (var i = 0; i < jsonDataLength; i++) {
      let timestamp = jsonData[i].timestamp;
      let data = jsonData[i].data;
      let comment = jsonData[i].comment;

      html +=
        "<div class='text-image-container'><div class='text'>" +
        timestamp +
        "</div><div class='text'>" +
        comment +
        "</div><div class='image'><img src='data:image/png;base64, " +
        data +
        "' /></div><hr></div>";
    }
    html = startPDF + html + endPDF;

    htmlWindow.loadURL("data:text/html," + html);
    htmlWindow.once("ready-to-show", () => {
      console.log("showing window");
      htmlWindow.show();
      const printOptions = {
        landscape: true,
        marginsType: 1,
        pageSize: "A4"
      };

      htmlWindow.webContents.printToPDF(printOptions).then(data => {
        console.log("writing pdf file");
        fs.writeFileSync(savePath, data, (error) => {
          if(error) {
            console.log(error);
          }
        });
      }).catch(error => {
        console.log(error);
      });

      setTimeout(function() {
        console.log("closing window");
        htmlWindow.close();
      },10000);
    });

    htmlWindow.webContents.openDevTools();

    global.htmlWindow = htmlWindow;
  }*/
});

// This method will be called when Electron has finished
// initialization and is ready to create browser windows.
// Some APIs can only be used after this event occurs.
app.on("ready", createWindow);

ipcMain.on("open-how-to", (event, args) => {
  const howToWindow = new BrowserWindow({
    width: 650,
    height: 280,
    frame: false,
    show: false,
    resizable: false,
    modal: true,
    webPreferences: {
      nodeIntegration: true,
      enableRemoteModule: true,
    },
    icon: __dirname + "/assets/icons/favicon-32x32.png",
  });

  howToWindow.loadURL(path.join(__dirname, "howto.html"));

  howToWindow.once("ready-to-show", () => {
    howToWindow.show();
  });

  howToWindow.webContents.send("howto-opened");

  global.howToWindow = howToWindow;
});

// Logging in main process only
ipcMain.on("log", (event, args) => {
  console.log(args);
});

// Quit when all windows are closed, except on macOS. There, it's common
// for applications and their menu bar to stay active until the user quits
// explicitly with Cmd + Q.
app.on("will-quit", () => {
  globalShortcut.unregisterAll();
});
app.on("window-all-closed", () => {
  if (process.platform !== "darwin") {
    app.quit();
  }
});

app.on("activate", () => {
  // On OS X it's common to re-create a window in the app when the
  // dock icon is clicked and there are no other windows open.
  if (BrowserWindow.getAllWindows().length === 0) {
    createWindow();
  }
});

// In this file you can include the rest of your app's specific main process
// code. You can also put them in separate files and import them here.

// some helper functions
function toInt32(bytes) {
  return (bytes[0] << 24) | (bytes[1] << 16) | (bytes[2] << 8) | bytes[3];
}

function getDimension(data) {
  return {
    width: toInt32(data.slice(16, 20)),
    height: toInt32(data.slice(20, 24)),
  };
}

var base64Characters =
  "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

function base64Decode(data) {
  var result = [];
  var current = 0;

  for (var i = 0, c; (c = data.charAt(i)); i++) {
    if (c === "=") {
      if (
        i !== data.length - 1 &&
        (i !== data.length - 2 || data.charAt(i + 1) !== "=")
      ) {
        throw new SyntaxError("Unexpected padding character.");
      }

      break;
    }

    var index = base64Characters.indexOf(c);

    if (index === -1) {
      throw new SyntaxError("Invalid Base64 character.");
    }

    current = (current << 6) | index;

    if (i % 4 === 3) {
      result.push(current >> 16, (current & 0xff00) >> 8, current & 0xff);
      current = 0;
    }
  }

  if (i % 4 === 1) {
    throw new SyntaxError("Invalid length for a Base64 string.");
  }

  if (i % 4 === 2) {
    result.push(current >> 4);
  } else if (i % 4 === 3) {
    current <<= 6;
    result.push(current >> 16, (current & 0xff00) >> 8);
  }

  return result;
}

function getPngDimensions(dataUri) {
  if (dataUri.substring(0, 22) !== "data:image/png;base64,") {
    throw new Error("Unsupported data URI format");
  }

  // 32 base64 characters encode the necessary 24 bytes
  return getDimension(base64Decode(dataUri.substr(22, 32)));
}
